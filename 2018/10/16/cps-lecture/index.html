<html>
<head>
	
	<title>CPS讲义</title>
	<meta name="keywords" content="Chris LEE,心神合一" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css" />

        
<script src="/js/util.js"></script>

        <script>
            if(isMobile()) {
                loadjscssfile('/css/mobile.css', 'css');
            } else {
                loadjscssfile('/css/desktop.css', 'css');
            }
        </script>
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3"/>
    
    

<meta name="generator" content="Hexo 7.3.0"></head>

<body>


<h2 class="title">CPS讲义</h2>
<!--
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2018年10月16日




 </div>
-->
</div>

<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPS%E8%AE%B2%E4%B9%89"><span class="toc-text">CPS讲义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E8%8B%B1%E5%AF%B9%E7%85%A7"><span class="toc-text">中英对照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A5%E6%BA%90%EF%BC%9A"><span class="toc-text">来源：</span></a></li></ol>
<h3 id="CPS讲义"><a href="#CPS讲义" class="headerlink" title="CPS讲义"></a>CPS讲义</h3><p>没有任何出版的书把这个主题讲明白了(包括Dan的书)</p>
<p>表达式<code>(f (g (h i) j) k)</code>哪个部分先被求值？<code>(h i)</code>，因为它必须在<code>(g (h i) j)</code>应用之前被求值。</p>
<p>那么<code>(f (g (h i) (j k)))</code>呢？Scheme没有指定参数求值顺序，所以<code>(h i)</code>和<code>(j k)</code>都可以先求值。</p>
<p>所以，我们自己决断。<code>(h i (lambda (hi) ...))</code> 假设hi是<code>(h i)</code>应用的结果，那么，我们替换掉在<code>...</code>中任何能被应用的东西：</p>
<p><code>(f (g (h i) (j l)))</code>变成<code>(h i (lambda (hi) (f (g hi (j l)))))</code></p>
<p><code>(lambda (hi) (f (g hi (j l))))</code>是一个延续，<code>hi</code>只在延续体中出现一次，因为<code>hi</code>将只替换<code>(h i)</code>。</p>
<span id="more"></span>

<p>让我们用CPS风格写个rember。首先，这是原始风格：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> rember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) &#x27;()][(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name"><span class="built_in">cdr</span></span> ls)]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) (<span class="name">rember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls)))])))</span><br></pre></td></tr></table></figure>

<p>第一条规则：任何时候，我们看到代码中的lambda，都必须增加一个参数，然后处理函数体：</p>
<p><code>(lambda (x ...) ...) =&gt; (lambda (x ... k) ...^)</code></p>
<p>我们先在外层lambda增加一个参数<code>k</code>：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> rember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls k)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) &#x27;()]</span><br><span class="line">      [(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name"><span class="built_in">cdr</span></span> ls)]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) (<span class="name">rember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls)))])))</span><br></pre></td></tr></table></figure>

<p>现在，来处理剩下的代码，我们得先介绍一条新的规则。</p>
<p>第二条规则：不要在意这些细节。</p>
<ul>
<li><p>小细节就是我们知道会马上终结的部分。</p>
</li>
<li><p>如果我们知道它会被求值，就不要处理它。</p>
</li>
<li><p>如果它<strong>可能</strong>会被求值，不要处理它，而应该传递给<code>k</code>。</p>
</li>
</ul>
<p>在第一行cond代码，<code>(null? ls)</code>是一个很好的例子。我们知道它会被求值，并且我们知道它是小细节，所以我们不必为它操心。</p>
<p>那么作为答案返回的那个<code>&#39;()</code>怎么办？第二条规则其余部分是，如果一个它可能会被求值，那么只需要传递给<code>k</code>。</p>
<p>应用第二条规则在第一行cond后，我们得到：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> rember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls k)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) (<span class="name">k</span> &#x27;())]</span><br><span class="line">      [(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name"><span class="built_in">cdr</span></span> ls)]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) (<span class="name">rember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls)))])))</span><br></pre></td></tr></table></figure>

<p>在第二行cond代码的判断条件和返回值中，都有小细节，所以我们可以像第一行代码一样对待它。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> rember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls k)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) (<span class="name">k</span> &#x27;())]</span><br><span class="line">      [(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name">k</span> (<span class="name"><span class="built_in">cdr</span></span> ls))]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) (<span class="name">rember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls)))])))</span><br></pre></td></tr></table></figure>

<p>在else分支，小细节<strong>不要</strong>作为返回值，所以我们必须创建一个新的延续：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> rember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls k)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) (<span class="name">k</span> &#x27;())]</span><br><span class="line">      [(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name">k</span> (<span class="name"><span class="built_in">cdr</span></span> ls))]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name">rember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls) (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) x)))])))</span><br></pre></td></tr></table></figure>

<p>我们还没有全部完成，因为我们还有一些小细节在延续体内。所以，我们只需要传递给<code>k</code>：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> rember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls k)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) (<span class="name">k</span> &#x27;())]</span><br><span class="line">      [(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name">k</span> (<span class="name"><span class="built_in">cdr</span></span> ls))]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name">rember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls) (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name">k</span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) x))))])))</span><br></pre></td></tr></table></figure>

<p>这是完全的CPS风格，但是，我们如何调用它？别忘了，我们需要把<code>k</code>传递进去。<br>因为<code>(rember8 &#39;() k)</code>应该返回<code>&#39;()</code>，<code>k</code>应该是个恒等函数<code>(lambda (x) x)</code>：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">rember8</span> &#x27;(<span class="number">1</span> <span class="number">2</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>) (<span class="name"><span class="built_in">lambda</span></span> (x) x))</span><br></pre></td></tr></table></figure>

<p>我们能看出到这个程序的什么性质？</p>
<p>首先，所有不是小细节的部分都是尾递归。程序里所有的尾递归都被星号标记：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> rember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls k)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) (<span class="name">*k*</span> &#x27;())]</span><br><span class="line">      [(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name">*k*</span> (<span class="name"><span class="built_in">cdr</span></span> ls))]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name">*rember8*</span> (<span class="name"><span class="built_in">cdr</span></span> ls) (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name">*k*</span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) x))))])))</span><br></pre></td></tr></table></figure>

<p>为什么<code>null?</code>,<code> =</code>,<code> car</code>, <code>cdr</code>和 <code>cons</code> 不是？因为他们是小细节，即使我们把小细节组合，仍然是微不足道的。</p>
<p>其次，所有的参数都是小细节。没错，即使是在else分支的lambda，因为lambda<strong>永远</strong>都是小细节。</p>
<p>注意，本质上这是一个C程序。所有我们需要做的都是把延续转换成数据结构(记住我们是如何用闭包完成同样的事)。</p>
<p>我们来追踪一下<code>(rember8  (lambda (x) x))</code></p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls | k</span><br><span class="line">&#x27;(<span class="number">1</span> <span class="number">2</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>) | (<span class="name"><span class="built_in">lambda</span></span> (x) x) = id</span><br><span class="line">&#x27;(<span class="number">2</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>)   | (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name">id</span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">1</span> x))) = k<span class="number">2</span></span><br><span class="line">&#x27;(<span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>)     | (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name">k2</span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">2</span> x))) = k<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>一旦我们命中8，我们应用<code>(k (cdr ls))</code>，此时<code>k</code>是<code>k3</code>，而<code>ls</code>是<code>&#39;(8 3 4 6 7 8 5)</code></p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">k3</span> &#x27;(<span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>)) = (<span class="name">k2</span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">2</span> &#x27;(<span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>)))</span><br><span class="line">(<span class="name">k2</span> &#x27;(<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>)) = (<span class="name">id</span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">1</span> &#x27;(<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>)))</span><br><span class="line">(<span class="name">id</span> &#x27;(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>)) = &#x27;(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>现在，我们完成了。</p>
<p>我们来尝试一个更复杂的程序，<code>multirember8</code>。不仅仅是移除第一个8，而是移除所有的8.</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> multirember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) &#x27;()]</span><br><span class="line">      [(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name">multirember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls))]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) (<span class="name">multirember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls)))])))</span><br></pre></td></tr></table></figure>

<p>现在，我们回到CPS风格的<code>rember8</code>进行CPS转换：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> multirember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls k)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) (<span class="name">k</span> &#x27;())]</span><br><span class="line">      [(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name">multirember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls))] <span class="comment">;; uh-oh!</span></span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name">multirember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls) (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name">k</span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) x))))])))</span><br></pre></td></tr></table></figure>

<p>我们需要在第二行做些什么？因为<code>multirember8</code>需要2个参数，我们现在需要传递一个延续。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> multirember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls k)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) (<span class="name">k</span> &#x27;())]</span><br><span class="line">      [(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name">multirember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls) (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name">k</span> x)))]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name">multirember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls) (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name">k</span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) x))))])))</span><br></pre></td></tr></table></figure>

<p>但是，<code>(lambda (x) (k x))</code>做了什么？它接受任何传递给它的参数，然后传递给<code>k</code>。因此，整个表达式，等同于<code>k</code>。</p>
<p>η约简：如果<code>x</code>在<code>M</code>中不是自由变量，并且保证<code>M</code>会终结，那么<code>(lambda (x) (M x)) = M</code>。<br><code>M</code>是满足这些规则的任意表达式。它不必是像<code>k</code>一样的单变量。</p>
<p>所以，任何时候看到尾递归，你都不需要想到η约简，只需要把它传递给k。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> multirember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls k)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) (<span class="name">k</span> &#x27;())][(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name">multirember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls) k)]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name">multirember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls) (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name">k</span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) x))))])))</span><br></pre></td></tr></table></figure>

<h3 id="中英对照"><a href="#中英对照" class="headerlink" title="中英对照"></a>中英对照</h3><p>CPS Lecture</p>
<p>CPS讲义</p>
<p>No published books do this subject justice (including Dan’s!)</p>
<p>没有任何出版的书把这个主题讲明白了(包括Dan的书)</p>
<p>Which part of <code>(f (g (h i) j) k)</code> can be done first? <code>(h i)</code>, since it must be evaluated before <code>(g (h i) j)</code> can be applied.</p>
<p>表达式<code>(f (g (h i) j) k)</code>哪个部分先被求值？<code>(h i)</code>，因为它必须在<code>(g (h i) j)</code>应用之前被求值。</p>
<p>What about <code>(f (g (h i) (j k)))</code>? Scheme doesn’t specify the order in which arguments are evaluated so it could be either <code>(h i)</code> or <code>(j k)</code>.</p>
<p>那么<code>(f (g (h i) (j k)))</code>呢？Scheme没有指定参数求值顺序，所以<code>(h i)</code>和<code>(j k)</code>都可以先求值。</p>
<p>So, let’s take control. <code>(h i (lambda (hi) ...))</code> We assume that hi is the result of applying <code>(h i)</code>. Then, we drop in everything else that has to be done to replace the <code>...</code>:</p>
<p>所以，我们自己决断。<code>(h i (lambda (hi) ...))</code> 假设hi是<code>(h i)</code>应用的结果，那么，我们替换掉在<code>...</code>中任何能被应用的东西：</p>
<p><code>(f (g (h i) (j l)))</code>becomes <code>(h i (lambda (hi) (f (g hi (j l)))))</code></p>
<p><code>(f (g (h i) (j l)))</code>变成<code>(h i (lambda (hi) (f (g hi (j l)))))</code></p>
<p><code>(lambda (hi) (f (g hi (j l))))</code> is a continuation. <code>hi</code> only appears once in the body of the continuation, because <code>hi</code> is intended to replace <code>(h i)</code> and only <code>(h i)</code>.</p>
<p><code>(lambda (hi) (f (g hi (j l))))</code>是一个延续，<code>hi</code>只在延续体中出现一次，因为<code>hi</code>将只替换<code>(h i)</code>。</p>
<p>Let’s write rember in CPS. First, the direct style:</p>
<p>让我们用CPS风格写个rember。首先，这是原始风格：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> rember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) &#x27;()][(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name"><span class="built_in">cdr</span></span> ls)]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) (<span class="name">rember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls)))])))</span><br></pre></td></tr></table></figure>

<p>First rule: whenever we see a lambda in the code we want to CPS, we have to add an argument, and then process the body:</p>
<p>第一条规则：任何时候，我们看到代码中的lambda，都必须增加一个参数，然后处理函数体：</p>
<p><code>(lambda (x ...) ...) =&gt; (lambda (x ... k) ...^)</code></p>
<p>Let’s start by adding a <code>k</code> to the outer lambda:</p>
<p>我们先在外层lambda增加一个参数<code>k</code>：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> rember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls k)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) &#x27;()]</span><br><span class="line">      [(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name"><span class="built_in">cdr</span></span> ls)]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) (<span class="name">rember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls)))])))</span><br></pre></td></tr></table></figure>

<p>Now, to handle the rest of the program, we have to introduce a new rule.</p>
<p>现在，来处理剩下的代码，我们得先介绍一条新的规则。</p>
<p>Second rule: “Don’t sweat the small stuff!”</p>
<p>第二条规则：不要在意这些细节！</p>
<ul>
<li>Small stuff is stuff we know will terminate right away.</li>
</ul>
<p>​       小细节就是我们知道会马上终结的部分。</p>
<ul>
<li>Don’t sweat the small stuff if we know it will be evaluated.</li>
</ul>
<p>​       如果我们知道它会被求值，就不要处理它。</p>
<ul>
<li>Don’t sweat the small stuff if it <em>might</em> be evaluated, but instead pass it to <code>k</code>.</li>
</ul>
<p>​       如果它可能会被求值，不要处理它，而应该传递给<code>k</code>。</p>
<p>A good example of the first is <code>(null? ls)</code> in the first cond line. We know it will be evaluated, and we know it’s small stuff, so we don’t have to worry about it.</p>
<p>在第一行cond代码，<code>(null? ls)</code>是一个很好的例子。我们知道它会被求值，并且我们知道它是小细节，所以我们不必为它操心。</p>
<p>What about the <code>&#39;()</code> that’s returned as an answer? The other part of the second rule is that if some small stuff <em>might</em> be evaluated, we just pass it to <code>k</code>.</p>
<p>那么作为答案返回的那个<code>&#39;()</code>怎么办？第二条规则其余部分是，如果一个它可能会被求值，那么只需要传递给<code>k</code>。</p>
<p>After applying the second rule to the first cond line, we get:</p>
<p>应用第二条规则在第一行cond后，我们得到：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> rember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls k)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) (<span class="name">k</span> &#x27;())]</span><br><span class="line">      [(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name"><span class="built_in">cdr</span></span> ls)]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) (<span class="name">rember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls)))])))</span><br></pre></td></tr></table></figure>

<p>The second cond line also has small stuff in both the test and the return value, so we can treat it just like the first line.</p>
<p>在第二行cond代码的判断条件和返回值中，都有小细节，所以我们可以像第一行代码一样对待它。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> rember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls k)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) (<span class="name">k</span> &#x27;())]</span><br><span class="line">      [(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name">k</span> (<span class="name"><span class="built_in">cdr</span></span> ls))]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) (<span class="name">rember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls)))])))</span><br></pre></td></tr></table></figure>
<p>The else case, however, does <em>not</em> have small stuff as a return value, so we have to build a new continuation:</p>
<p>在else分支，小细节<strong>不要</strong>作为返回值，所以我们必须创建一个新的延续：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> rember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls k)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) (<span class="name">k</span> &#x27;())]</span><br><span class="line">      [(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name">k</span> (<span class="name"><span class="built_in">cdr</span></span> ls))]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name">rember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls) (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) x)))])))</span><br></pre></td></tr></table></figure>

<p>We’re not quite done, though, since we now have small stuff in the body of the continuation. So, we just pass it to <code>k</code>:</p>
<p>我们还没有全部完成，因为我们还有一些小细节在延续体内。所以，我们只需要传递给<code>k</code>：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> rember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls k)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) (<span class="name">k</span> &#x27;())]</span><br><span class="line">      [(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name">k</span> (<span class="name"><span class="built_in">cdr</span></span> ls))]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name">rember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls) (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name">k</span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) x))))])))</span><br></pre></td></tr></table></figure>
<p>This is now completely CPSed, but how do we invoke it? After all, we need a <code>k</code> to pass in. Since <code>(rember8 &#39;() k)</code> should be <code>&#39;()</code>,<code> k</code> can be the identity function <code>(lambda (x) x)</code>:</p>
<p>这是完全的CPS风格，但是，我们如何调用它？别忘了，我们需要把<code>k</code>传递进去。因为<code>(rember8 &#39;() k)</code>应该返回<code>&#39;()</code>，<code>k</code>应该是个恒等函数<code>(lambda (x) x)</code>：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">rember8</span> &#x27;(<span class="number">1</span> <span class="number">2</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>) (<span class="name"><span class="built_in">lambda</span></span> (x) x))</span><br></pre></td></tr></table></figure>

<p>What properties can we observe about this program?</p>
<p>我们能看出到这个程序的什么性质？</p>
<p>First, all non-small stuff calls are tail calls. Here’s the program with the tail calls surrounded by asterisks:</p>
<p>首先，所有不是小细节的部分都是尾递归。程序里所有的尾递归都被星号标记：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> rember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls k)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) (<span class="name">*k*</span> &#x27;())]</span><br><span class="line">      [(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name">*k*</span> (<span class="name"><span class="built_in">cdr</span></span> ls))]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name">*rember8*</span> (<span class="name"><span class="built_in">cdr</span></span> ls) (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name">*k*</span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) x))))])))</span><br></pre></td></tr></table></figure>
<p>Why don’t <code>null?</code>,<code> =</code>,<code> car</code>,<code> cdr</code>, and <code>cons</code> count? Because they’re just small stuff, and when we combine small stuff together in small ways, the combination remains small.</p>
<p>为什么<code>null?</code>,<code> =</code>,<code> car</code>, <code>cdr</code>和 <code>cons</code> 不是？因为他们是小细节，即使我们把小细节组合，仍然是微不足道的。</p>
<p>Second, all arguments are small stuff. Yep, even the lambda in the else line, because lambda is <em>always</em> small stuff.</p>
<p>其次，所有的参数都是小细节。没错，即使是在else分支的lambda，因为lambda<strong>永远</strong>都是小细节。</p>
<p>Notice that this is essentially a C program. All we have to do is convert the continuations to data structures (remember how we did the same thing with closures).</p>
<p>注意，本质上这是一个C程序。所有我们需要做的都是把延续转换成数据结构(记住我们是如何用闭包完成同样的事)。</p>
<p>Let’s trace <code>(rember8  (lambda (x) x))</code></p>
<p>我们来追踪一下<code>(rember8  (lambda (x) x))</code></p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls | k</span><br><span class="line">&#x27;(<span class="number">1</span> <span class="number">2</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>) | (<span class="name"><span class="built_in">lambda</span></span> (x) x) = id</span><br><span class="line">&#x27;(<span class="number">2</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>)   | (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name">id</span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">1</span> x))) = k<span class="number">2</span></span><br><span class="line">&#x27;(<span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>)     | (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name">k2</span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">2</span> x))) = k<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Once we hit the 8, we apply <code>(k (cdr ls))</code> where <code>k</code> is <code>k3</code> and <code>ls</code> is <code>&#39;(8 3 4 6 7 8 5)</code></p>
<p>一旦我们命中8，我们应用<code>(k (cdr ls))</code>，此时<code>k</code>是<code>k3</code>，而<code>ls</code>是<code>&#39;(8 3 4 6 7 8 5)</code></p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">k3</span> &#x27;(<span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>)) = (<span class="name">k2</span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">2</span> &#x27;(<span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>)))</span><br><span class="line">(<span class="name">k2</span> &#x27;(<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>)) = (<span class="name">id</span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">1</span> &#x27;(<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>)))</span><br><span class="line">(<span class="name">id</span> &#x27;(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>)) = &#x27;(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>And we’re done.</p>
<p>现在，我们完成了。</p>
<p>Let’s try a more complicated program, <code>multirember8</code>. Instead of just removing the first 8, it’ll remove all of the 8s.</p>
<p>我们来尝试一个更复杂的程序，<code>multirember8</code>。不仅仅是移除第一个8，而是移除所有的8。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> multirember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) &#x27;()]</span><br><span class="line">      [(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name">multirember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls))]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) (<span class="name">multirember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls)))])))</span><br></pre></td></tr></table></figure>
<p>Now, let’s start CPSing by going back to our CPSed <code>rember8</code>:</p>
<p>现在，我们回到CPS风格的<code>rember8</code>进行CPS转换：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> multirember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls k)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) (<span class="name">k</span> &#x27;())]</span><br><span class="line">      [(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name">multirember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls))] <span class="comment">;; uh-oh!</span></span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name">multirember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls) (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name">k</span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) x))))])))</span><br></pre></td></tr></table></figure>
<p>What do we need to do for the second line? Since <code>multirember8</code> takes two arguments, we need to now pass it a continuation.</p>
<p>我们需要在第二行做些什么？因为<code>multirember8</code>需要2个参数，我们现在需要传递一个延续。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> multirember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls k)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) (<span class="name">k</span> &#x27;())]</span><br><span class="line">      [(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name">multirember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls) (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name">k</span> x)))]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name">multirember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls) (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name">k</span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) x))))])))</span><br></pre></td></tr></table></figure>
<p>But what’s <code>(lambda (x) (k x))</code> doing? It’s taking whatever is passed to it, and passing it to <code>k</code>. This whole expression, therefore, is equivalent to <code>k</code>.</p>
<p>但是，<code>(lambda (x) (k x))</code>做了什么？它接受任何传递给它的参数，然后传递给<code>k</code>。因此，整个表达式，等同于<code>k</code>。</p>
<p>Eta reduction: <code>(lambda (x) (M x)) = M</code> if <code>x</code> is not free in <code>M</code> and <code>M</code> is guaranteed to terminate. <code>M</code> is any arbitrary expression that satisfies these rules; it doesn’t have to be only a single variable like <code>k</code>.</p>
<p>η约简：如果<code>x</code>在<code>M</code>中不是自由变量，并且保证<code>M</code>会终结，那么<code>(lambda (x) (M x)) = M</code>。<br><code>M</code>是满足这些规则的任意表达式。它不必是像<code>k</code>一样的单变量。</p>
<p>So, whenever you see a tail call, you don’t even have to think about eta. Just pass <code>k</code> to it.</p>
<p>所以，任何时候看到尾递归，你都不需要想到η约简，只需要把它传递给k。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> multirember8</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (ls k)</span><br><span class="line">    (<span class="name"><span class="built_in">cond</span></span></span><br><span class="line">      [(<span class="name"><span class="built_in">null?</span></span> ls) (<span class="name">k</span> &#x27;())][(<span class="name"><span class="built_in">=</span></span> (<span class="name"><span class="built_in">car</span></span> ls) <span class="number">8</span>) (<span class="name">multirember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls) k)]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name">multirember8</span> (<span class="name"><span class="built_in">cdr</span></span> ls) (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name">k</span> (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">car</span></span> ls) x))))])))</span><br></pre></td></tr></table></figure>

<h3 id="来源："><a href="#来源：" class="headerlink" title="来源："></a>来源：</h3><p><a target="_blank" rel="noopener" href="https://cgi.soic.indiana.edu/~c311/doku.php">Indiana University C311</a></p>


<!--<a href="https://blog.chrislee.fun/2018/10/16/cps-lecture/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = ''; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=&web_id=" language="JavaScript"></script>script>
</div>






</body>
</html>